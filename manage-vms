#!/bin/bash

# resolve script dir (handles symlinks)
SOURCE="${BASH_SOURCE[0]}"
while [ -h "${SOURCE}" ]; do
  DIR="$(cd -P "$(dirname "${SOURCE}")" >/dev/null 2>&1 && pwd)"
  SOURCE="$(readlink "${SOURCE}")"
  [[ "${SOURCE}" != /* ]] && SOURCE="${DIR}/${SOURCE}"
done
SD="$(cd -P "$(dirname "${SOURCE}")" >/dev/null 2>&1 && pwd)"

ACTION=""

VM_BASE_NAME_EXAMPLE="u22-server-template"
VM_BASE_PATTERN_EXAMPLE="u22-server-{1..3}"
VM_NAME_PATTERN_EXAMPLE="u22-server-{1..3}-clone"
VM_OLD_IP_PATTERN_EXAMPLE="192.168.122.{10..12}"
VM_NEW_IP_PATTERN_EXAMPLE="10.0.0.{10..12}"
PASSWORD_FILE_EXAMPLE="/path/to/password.txt"
SSH_USER_EXAMPLE=$(whoami)
SSH_KEY_EXAMPLE="$HOME/.ssh/id_rsa"

VM_BASE_PATTERN=""
VM_NAME_PATTERN=""
VM_OLD_IP_PATTERN=""
VM_NEW_IP_PATTERN=""
PASSWORD_FILE=""
SSH_USER=""
SSH_KEY=""

function showHelp() {
  cat <<USAGE >&2
  Usage: $(basename "${0}") <action> [options]

  Actions (one required):
    start    : Start one or more VMs.
               Required flags: --name-pattern | -n

    stop     : Stop one or more VMs.
               Required flags: --name-pattern | -n

    clone    : Clone VM(s). Clone source can be a single VM or one per target.
               Required flags: --base-pattern | -b   (existing VM(s) to clone from)
                               --name-pattern | -n   (new VM name(s))

    delete   : Delete one or more VMs.
               Required flags: --name-pattern | -n

    init     : Initialise a VM (hostname + IP replacement + SSH setup).
               Required flags: --name-pattern | -n
                               --existing-ip-pattern | -e
                               --new-ip-pattern | -i
                               --password-file | -f
                               --ssh-user | -u
                               --ssh-key | -k

  Flag details:
    -b, --base-pattern         Pattern that expands to the existing VM name(s) to clone.
    -n, --name-pattern         Pattern that expands to target VM name(s).
    -e, --existing-ip-pattern  Pattern or list of current/temporary IPs for the VMs.
    -i, --new-ip-pattern       Pattern or list of desired final IPs for the VMs.
    -f, --password-file        Local file containing passwords used by init routines.
    -u, --ssh-user             SSH user to connect as when initialising VMs.
    -k, --ssh-key              Path to the SSH private key to use for initialising VMs.
    -h, --help                 Show this help.

  Examples:
    # Start a set of cloned VMs
    $(basename "${0}") start -n "${VM_NAME_PATTERN_EXAMPLE}"

    # Stop the same set
    $(basename "${0}") stop -n "${VM_NAME_PATTERN_EXAMPLE}"

    # Clone three VMs from a single base -> three targets
    $(basename "${0}") clone -b "${VM_BASE_PATTERN_EXAMPLE}" \\
      -n "${VM_NAME_PATTERN_EXAMPLE}"

    # Clone a single base VM to multiple targets (single-source -> many)
    $(basename "${0}") clone -b "${VM_BASE_NAME_EXAMPLE}" \\
      -n "${VM_NAME_PATTERN_EXAMPLE}"

    # Delete the cloned VMs
    $(basename "${0}") delete -n "${VM_NAME_PATTERN_EXAMPLE}"

    # Initialise VMs (replace IPs, set SSH access)
    $(basename "${0}") init \\
      -n "${VM_NAME_PATTERN_EXAMPLE}" \\
      -e "${VM_OLD_IP_PATTERN_EXAMPLE}" \\
      -i "${VM_NEW_IP_PATTERN_EXAMPLE}" \\
      -f "${PASSWORD_FILE_EXAMPLE}" \\
      -u "${SSH_USER_EXAMPLE}" \\
      -k "${SSH_KEY_EXAMPLE}"

USAGE
  exit "${1:-0}"
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    start)
      ACTION="start"
      shift
      ;;
    stop)
      ACTION="stop"
      shift
      ;;
    clone)
      ACTION="clone"
      shift
      ;;
    delete)
      ACTION="delete"
      shift
      ;;
    init)
      ACTION="init"
      shift
      ;;
    -b|--base-pattern)
      VM_BASE_PATTERN="$2"
      shift 2
      ;;
    -n|--name-pattern)
      VM_NAME_PATTERN="$2"
      shift 2
      ;;
    -i|--new-ip-pattern)
      VM_NEW_IP_PATTERN="$2"
      shift 2
      ;;
    -e|--existing-ip-pattern)
      VM_OLD_IP_PATTERN="$2"
      shift 2
      ;;
    -f|--password-file)
      if [[ -z "$2" || "$2" == -* ]]; then
        echo "ERROR: --password-file requires a file path argument."
        exit 1
      fi
      if [[ ! -f "$2" ]]; then
        echo "ERROR: Password file '$2' does not exist."
        exit 1
      fi
      PASSWORD_FILE="$2"
      shift 2
      ;;
    -u|--ssh-user)
      SSH_USER="$2"
      shift 2
      ;;
    -k|--ssh-key)
      SSH_KEY="$2"
      shift 2
      ;;
    -h|--help)
      showHelp
      ;;
    *)
      echo "Unknown option: $1"
      showHelp 1
      ;;
  esac
done

function executeScriptWithPassword() {
  if [ -z "${PASSWORD_FILE}" ] || [ ! -f "${PASSWORD_FILE}" ]; then
    "$@"
    return $?
  fi
  local password
  password=$(<"${PASSWORD_FILE}")
expect <<EOF
set timeout 60
spawn -noecho /bin/sh -c "$@"
expect {
  -re "(?i)password" {
    send "$password\r"
    exp_continue
  }
  eof
}
catch wait
EOF
  return $?
}

function getNamesFromPattern() {
  python3 "${SD}/util/parse_pattern.py" "${1}"
}

function startVMs() {
  if [ -z "${VM_NAME_PATTERN}" ]; then
    echo "Error: VM name pattern must be specified for start action." >&2
    showHelp 1
  fi

  # Read names into an array safely
  local -a names=()
  old_ifs=$IFS
  IFS=$'\n'
  set -f
  for line in $(getNamesFromPattern "${VM_NAME_PATTERN}"); do
    line=${line//$'\r'/}
    line=$(echo "$line" | xargs)
    names+=("$line")
  done
  set +f
  IFS=$old_ifs
  for name in "${names[@]}"; do
    executeScriptWithPassword "${SD}/start-vm" --vm-name "${name}"
  done
}

function stopVMs() {
  if [ -z "${VM_NAME_PATTERN}" ]; then
    echo "Error: VM name pattern must be specified for stop action." >&2
    showHelp 1
  fi

  local -a names=()
  old_ifs=$IFS
  IFS=$'\n'
  set -f
  for line in $(getNamesFromPattern "${VM_NAME_PATTERN}"); do
    line=${line//$'\r'/}
    line=$(echo "$line" | xargs)
    names+=("$line")
  done
  set +f
  IFS=$old_ifs
  for name in "${names[@]}"; do
    executeScriptWithPassword "${SD}/stop-vm" --vm-name "${name}"
  done
}

function cloneVMs() {
  if [ -z "${VM_BASE_PATTERN}" ]; then
    echo "Error: VM base pattern must be specified for clone action." >&2
    showHelp 1
  fi
  if [ -z "${VM_NAME_PATTERN}" ]; then
    echo "Error: VM name pattern must be specified for clone action." >&2
    showHelp 1
  fi
  # read patterns into arrays (one name per line) without using mapfile for portability
  local -a clone_from_names=()
  local -a names=()

  local old_ifs=$IFS
  IFS=$'\n'
  set -f  # disable globbing
  for line in $(getNamesFromPattern "${VM_BASE_PATTERN}"); do
    # remove any CRs and trim surrounding whitespace
    line=$(echo "${line}" | tr -d '\r' | xargs)
    clone_from_names+=("${line}")
  done

  for line in $(getNamesFromPattern "${VM_NAME_PATTERN}"); do
    line=$(echo "${line}" | tr -d '\r' | xargs)
    names+=("${line}")
  done
  set +f
  IFS=$old_ifs

  local num_clone_from=${#clone_from_names[@]}
  local num_names=${#names[@]}

  # validate lengths: base must be either 1 (single source) or equal to number of target names
  if [ "${num_clone_from}" -ne 1 ] && [ "${num_clone_from}" -ne "${num_names}" ]; then
    echo "Error: base pattern must expand to either 1 or the same number of names as the target pattern." >&2
    echo "Base count: ${num_clone_from}, Target count: ${num_names}" >&2
    showHelp 2
  fi

  local base_name="${clone_from_names[0]}"
  local new_name=""
  local i
  base_name=$(echo "${base_name}" | tr -d '\r' | xargs)
  for ((i=0; i<num_names; i++)); do
    if [ "${num_clone_from}" -gt 1 ]; then
      base_name="${clone_from_names[$i]}"
      base_name=$(echo "${base_name}" | tr -d '\r' | xargs)
    fi
    new_name="${names[$i]}"
    new_name=$(echo "${new_name}" | tr -d '\r' | xargs)
    executeScriptWithPassword "${SD}/clone-vm" --existing-vm-name "${base_name}" --new-vm-name "${new_name}"
  done
}

function deleteVMs() {
  if [ -z "${VM_NAME_PATTERN}" ]; then
    echo "Error: VM name pattern must be specified for delete action." >&2
    showHelp 1
  fi

  local -a names=()
  old_ifs=$IFS
  IFS=$'\n'
  set -f
  for line in $(getNamesFromPattern "${VM_NAME_PATTERN}"); do
    line=${line//$'\r'/}
    line=$(echo "$line" | xargs)
    names+=("$line")
  done
  set +f
  IFS=$old_ifs
  for name in "${names[@]}"; do
    executeScriptWithPassword "${SD}/delete-vm" --vm-name "${name}"
  done
}

function initVMs() {
  if [ -z "${VM_NAME_PATTERN}" ]; then
    echo "Error: VM name pattern must be specified for init action." >&2
    showHelp 1
  fi
  if [ -z "${VM_OLD_IP_PATTERN}" ] || [ -z "${VM_NEW_IP_PATTERN}" ]; then
    echo "Error: Both old IP pattern and new IP pattern must be specified for init action." >&2
    showHelp 1
  fi
  if [ -z "${PASSWORD_FILE}" ]; then
    echo "Error: Password file must be specified for init action." >&2
    showHelp 1
  fi
  if [ -z "${SSH_USER}" ]; then
    echo "Error: SSH user must be specified for init action." >&2
    showHelp 1
  fi
  if [ -z "${SSH_KEY}" ]; then
    echo "Error: SSH key must be specified for init action." >&2
    showHelp 1
  fi

  # populate arrays safely
  local -a names=()
  local -a old_ips=()
  local -a new_ips=()
  old_ifs=$IFS
  IFS=$'\n'
  set -f
  for line in $(getNamesFromPattern "${VM_NAME_PATTERN}"); do
    line=${line//$'\r'/}
    line=$(echo "$line" | xargs)
    names+=("$line")
  done
  for line in $(getNamesFromPattern "${VM_OLD_IP_PATTERN}"); do
    line=${line//$'\r'/}
    line=$(echo "$line" | xargs)
    old_ips+=("$line")
  done
  for line in $(getNamesFromPattern "${VM_NEW_IP_PATTERN}"); do
    line=${line//$'\r'/}
    line=$(echo "$line" | xargs)
    new_ips+=("$line")
  done
  set +f
  IFS=$old_ifs

  local num_names=${#names[@]}
  local num_old_ips=${#old_ips[@]}
  local num_new_ips=${#new_ips[@]}

  if [ "${num_old_ips}" -ne "${num_names}" ] || [ "${num_new_ips}" -ne "${num_names}" ]; then
    echo "Error: The number of old IPs and new IPs must match the number of VM names." >&2
    echo "VM names: ${num_names}" >&2
    echo "Old IPs: ${num_old_ips}" >&2
    echo "New IPs: ${num_new_ips}" >&2
    showHelp 1
  fi

  local i=0
  local name=""
  local old_ip=""
  local new_ip=""
  for ((i=0; i<num_names; i++)); do
    name="${names[$i]}"
    old_ip="${old_ips[$i]}"
    new_ip="${new_ips[$i]}"
    "${SD}/init-vm" \
      --hostname "${name}" \
      --existing-ip "${old_ip}" \
      --new-ip "${new_ip}" \
      --password-file "${PASSWORD_FILE}" \
      --ssh-user "${SSH_USER}" \
      --ssh-key "${SSH_KEY}"
  done
}

if ! command -v expect >/dev/null 2>&1; then
  echo "Installing 'expect' package..."
  sudo apt update
  sudo apt install expect -y
fi

if ! command -v expect >/dev/null 2>&1; then
  echo "'expect' is required but not installed. Please install it and try again."
  exit 1
fi

case "$ACTION" in
  start)
    startVMs
    ;;
  stop)
    stopVMs
    ;;
  clone)
    cloneVMs
    ;;
  delete)
    deleteVMs
    ;;
  init)
    initVMs
    ;;
  *)
    echo "No valid action specified. Use 'start', 'stop', 'clone', or 'delete'."
    showHelp 1
    ;;
esac
